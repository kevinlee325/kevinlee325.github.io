<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on Kevin Lee</title>
        <link>https://kevinlee325.github.io/posts/</link>
        <description>Recent content in Posts on Kevin Lee</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <lastBuildDate>Sun, 25 Apr 2021 00:00:00 +0000</lastBuildDate>
        <atom:link href="https://kevinlee325.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>A Method of Constructing Analytic Signals by Fourier Transform</title>
            <link>https://kevinlee325.github.io/posts/2021/04/a-method-of-constructing-analytic-signals-by-fourier-transform/</link>
            <pubDate>Sun, 25 Apr 2021 00:00:00 +0000</pubDate>
            
            <guid>https://kevinlee325.github.io/posts/2021/04/a-method-of-constructing-analytic-signals-by-fourier-transform/</guid>
            <description>Abstract  In SD-OCT system, Hilbert Transform takes part in generating I-K (Intensity-wavenumber) relationship from I-λ(Intensity-wavelength), by constructing an analytic signal and calculating the phase of received signal. With the help of some FFT libraries, implementing Fourier Transform multiple times can replace Hilbert Transform and get the analytic signal, which is faster than implementing Hilbert Transform itself. This essay will focus on Hilbert Transform, replacing Hilbert Transform by Fourier Transform and how to implement it in C++.</description>
            <content type="html"><![CDATA[<h2 id="abstract">Abstract</h2>
<p>  In SD-OCT system, Hilbert Transform takes part in generating I-K (Intensity-wavenumber) relationship from I-λ(Intensity-wavelength), by constructing an analytic signal and calculating the phase of received signal. With the help of some FFT libraries, implementing Fourier Transform multiple times can replace Hilbert Transform and get the analytic signal, which is faster than implementing Hilbert Transform itself. This essay will focus on Hilbert Transform, replacing Hilbert Transform by Fourier Transform and how to implement it in C++.</p>
<h2 id="background">Background</h2>
<p>  In SD-OCT, we split different lights by their wavelength through a spectrometer. After that, a CCD camera will record the intensity(I) of different lights, thus forming a relation of I-λ. Based on the theory of OCT, we use Fourier Transform to get an Ascan from the relation of I-K. The most import thing in the process is to get the phase of received signal, in which case Hilbert Transform works. It is easy to do FFT in C++ with the help of a library called FFTW and Hilbert Transform can be replaced by multiple Fourier Transforms.</p>
<h2 id="hilbert-transform">Hilbert Transform</h2>
<p>  The definition of Hilbert Transform is</p>
<p>$$
\begin{aligned}
\hat{x}(t) &amp;=H[x(t)] \\\<br>
&amp;=x(t) * \frac{1}{\pi t} \\\<br>
&amp;=\frac{1}{\pi} \int_{-\infty}^{\infty} \frac{x(\tau)}{t-\tau} d \tau
\end{aligned}
$$</p>
<p>  $x(t)$ is the original signal. H represents Hilbert Transform and $\hat{x}(t)$ is the result of Hilbert Transform. 
The process of Hilbert Transform can be described as a signal passing through a Linear and Time-invariant System(LTI) . The impulse response of the system is</p>
<p>$$
h(t)=\frac{1}{\pi t}
$$</p>
<p>,whose Fourier Transform is</p>
<p>$$
\begin{array}{c}
H(f)=-j \operatorname{sgn}(f) \\\<br>
\quad=|H(f)| e^{j \phi(f)}
\end{array}
$$</p>
<p>  $\operatorname{sgn}(f)$ is the sign function and its definition is</p>
<p>$$
\operatorname{sgn}(f)=\left\{\begin{array}{ll}
1 &amp; f&gt;0 \\\<br>
0 &amp; f=0 \\\<br>
-1 &amp; f&lt;0
\end{array} \right.
$$</p>
<p>  Thus, the Fourier Transform of $\hat{x}(t)$ is</p>
<p>$$
\begin{aligned}
\hat{X}(f) &amp;=X(f) \cdot H(f) \\\<br>
&amp;=X(f) \cdot (-j \operatorname{sgn}(f)) \\\<br>
&amp;=-j X(f) \cdot \operatorname{sgn}(f)
\end{aligned}
$$</p>
<p>$$
\hat{X}(f)=\left\{\begin{array}{ll}
-j X(f) &amp; f&gt;0 \\\<br>
0 &amp; f=0 \\\<br>
j X(f) &amp; f&lt;0
\end{array}\right.
$$</p>
<p>  With the result of Hilbert Transform, we can generate the analytic signal of $x(t)$ as</p>
<p>$$
\tilde{x}=x(t)+j \hat{x}(t)=A(t) e^{j \Phi(t)}
$$</p>
<p>  Hence, the principal argument angle of signal $x(t)$ is $\operatorname{actan}\left(\frac{x(t)}{\hat{x}(t)}\right)$</p>
<h2 id="fourier-transform-of-the-analytic-signal">Fourier Transform of the analytic signal</h2>
<p>  Perform Fourier Transform on the analytic signal and we can get:</p>
<p>$$
\tilde{X}(f)=X(f)+j \hat{X}(f) 
\hat{X}(f)=\left\{\begin{array}{ll}
2 X(f) &amp; f&gt;0 \\\<br>
0 &amp; f=0 \\\<br>
0 &amp; f&lt;0
\end{array}\right.
$$</p>
<p>  We can conclude that the negative side of the spectrum of the analytic signal is suppressed and the positive side of the spectrum is just the spectrum of the original signal $x(t)$ multiplied by 2.</p>
<h2 id="replace-hilbert-transform-by-fourier-transform">Replace Hilbert Transform by Fourier Transform</h2>
<p>  According to the previous introduction, the positive side of $x(t)$’s spectrum is the spectrum of the analytic signal multiplied by $1/2$. Therefore, we can perform once Fourier Transform on the original signal $x(t)$, modify the spectrum and perform once inverse Fourier Transform to get the analytic signal. 
Based on the background of the essay, we want to get the analytic signal of the discrete signal acquired by a CCD camera which has 2048 sensors. Thus, this essay will continue to give out details in the field of digital signal processing.
<br/>  Now, the original signal is $x(n)$, which is sampled from $x(t)$, $0\leq n&lt;N$, and $N$ is 2048. The spectrum of $x(t)$ is shown in Figure 1.</p>
<div align="center">
<img src="/post1/ft.png" height="300">
<center><font color="#FFFFFF">Figure 1. Fourier Transform of continous signal $x(t)$</font></center>
 </div>
 <br/>  
&ensp;&ensp;The spectrum of sampled signal is the extension of Figure 1. with period of sampling period, as shown in Figure 2.
 <br/>
 <br/>  
<div align="center">
<img src="/post1/dtft.png">
<center><font color="#FFFFFF">Figure 2. Discrete Time Fourier Transform of sampled signal</font></center>
 </div>
 <br/>   
<p>  The spectrum information contained in Figure 2. is redundant and computer can only process discrete data, so we perform DFT on signal $x(n)$ and it can be explained as sampling $N$ points within a period of DTFT. The DFT result is shown in Figure 3 as below.</p>
<div align="center">
<img src="/post1/dft.png">
<center><font color="#FFFFFF">Figure 3. Discrete Fourier Transform of N-points sampled signal $x(n)$</font></center>
 </div>
 <br/>  
<p>  After suppressing the negative part of spectrum and multiplying the amplitude by 2, we get the spectrum of the analytic signal corresponding to $x(n)$. Here, we can easily get the analytic signal we want by inverse DFT.</p>
<div align="center">
<img src="/post1/analyticsignalFFT.png">
<center><font color="#FFFFFF">Figure 3. Discrete Fourier Transform of $x(n)$'s analytic signal</font></center>
 </div>
 <br/>  
<p>  The content above gives an overall explanation. Given a record of samples $x(n)$ of even length N, the procedure to construct the analytic signal $z(n)$ is as follows.
$$
z(n)=\mathcal{F}^{-1}\{\mathcal{F}\{x(n)\} \circ Z(k)\}
$$
where:
<br/>               $x(n)$&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;input signal
<br/>               $\mathcal{F}$&mdash;&mdash;&mdash;-DFT
<br/>               $\mathcal{F}^{-1}$&mdash;&ndash;IDFT
<br/>               $\circ$&mdash;&mdash;&mdash;&mdash;&mdash;- entrywise product</p>
<p>and:
$$
Z(k)=\left\{\begin{array}{ll}
1 &amp; k=0, \frac{N}{2} \\\<br>
2 &amp; k=1,2, \ldots, \frac{N}{2}-1 \\\<br>
0 &amp; \text { otherwise. }
\end{array}\right.
$$</p>
<p>                  (N&ndash;number of samples)</p>
<h2 id="implement-in-c">Implement in C++</h2>
<p>  The code shown below implements the process of computing analytic signal and is based on FFTW(a c++ library for FFT). You can refer to the manual if you are not familiar with it.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++">
<span style="color:#75715e">// macros for the real and imaginary parts
</span><span style="color:#75715e"></span><span style="color:#75715e">#define REAL 0
</span><span style="color:#75715e">#define IMAG 1
</span><span style="color:#75715e"></span><span style="color:#75715e">// length of the complex arrays
</span><span style="color:#75715e"></span><span style="color:#75715e">#define N 7
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Hilbert</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">double</span><span style="color:#f92672">*</span> In, fftw_complex<span style="color:#f92672">*</span> Out)
{
	<span style="color:#75715e">//copy the data into the complex array
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> N; <span style="color:#f92672">++</span>i)
	{
		Out[i][REAL] <span style="color:#f92672">=</span> In[i];
		Out[i][IMAG] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
	}

	<span style="color:#75715e">//creat a DFT plan and execute it
</span><span style="color:#75715e"></span>	fftw_plan plan <span style="color:#f92672">=</span> fftw_plan_dft_1d(N, Out, Out, FFTW_FORWARD, FFTW_ESTIMATE);
	fftw_execute(plan);

	<span style="color:#75715e">//destroy the plan to prevent a memory leak
</span><span style="color:#75715e"></span>	fftw_destroy_plan(plan);

	<span style="color:#66d9ef">int</span> HN <span style="color:#f92672">=</span> N <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">1</span>;  <span style="color:#75715e">// half of the length (N/2)
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">int</span> NumRem <span style="color:#f92672">=</span> HN;  <span style="color:#75715e">//the number of remaining elements
</span><span style="color:#75715e"></span>
	<span style="color:#75715e">//multiply the appropriate values by 2
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//(those that should be multiplied by 1 are left intact because they wouldn&#39;t change)
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> HN; <span style="color:#f92672">++</span>i)
	{
		Out[i][REAL] <span style="color:#f92672">*=</span> <span style="color:#ae81ff">2</span>;
		Out[i][IMAG] <span style="color:#f92672">*=</span> <span style="color:#ae81ff">2</span>;
	}

	<span style="color:#75715e">//if the length is even, the number of remaining elements decreases by 1
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (N <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
		NumRem<span style="color:#f92672">--</span>;
	<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (N <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span>)  <span style="color:#75715e">//if it&#39;s odd and greater than 1, the middle value must be multiplied by 2
</span><span style="color:#75715e"></span>	{
		Out[HN][REAL] <span style="color:#f92672">*=</span> <span style="color:#ae81ff">2</span>;
		Out[HN][IMAG] <span style="color:#f92672">*=</span> <span style="color:#ae81ff">2</span>;
	}

	<span style="color:#75715e">//set the remaining values to 0
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//(multiplying by 0 gives 0, so we don&#39;t care about the multiplicands)
</span><span style="color:#75715e"></span>	memset(<span style="color:#f92672">&amp;</span>Out[HN <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>][REAL], <span style="color:#ae81ff">0</span>, NumRem <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span>(fftw_complex));

	<span style="color:#75715e">//creat a IDFT plan and execute it
</span><span style="color:#75715e"></span>	plan <span style="color:#f92672">=</span> fftw_plan_dft_1d(N, Out, Out, FFTW_BACKWARD, FFTW_ESTIMATE);
	fftw_execute(plan);

	<span style="color:#75715e">//do some cleaning
</span><span style="color:#75715e"></span>	fftw_destroy_plan(plan);
	fftw_cleanup();

	<span style="color:#75715e">//scale the IDFT output
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> N; <span style="color:#f92672">++</span>i)
	{
		Out[i][REAL] <span style="color:#f92672">/=</span> N;
		Out[i][IMAG] <span style="color:#f92672">/=</span> N;
	}
}
</code></pre></div>]]></content>
        </item>
        
    </channel>
</rss>
